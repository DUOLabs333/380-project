NOTE: The analysis was specifically on the source code located [here](https://github.com/Nieves350/Projects-), on branch `CSC-380`, commit 3fb3040.

We'll start the analysis by noting that the program, in its current form, fails to function correctly as a chat program, let alone a chat program that uses encryption correctly --- while the project does compile, and the server and client do start up correctly, trying to either send or receive a message results in an immediate segfault. In the spirit of transparency, it should also be noted that this flaw is acknowledged in the README of the project.

When the source code of the project was compared to the original template provided by the professor, it was found that the only file that was modified was chat.c, so this analysis focuses only on flaws that were found in that file. One such flaw was found on line 175, with the statement `mpz_export(NULL, NULL, 1, sizeof(public_key), 0, 0, public_key);` --- mpz_export, which is provided by the gmp library, has a declaration of `mpz_export (void *rop, size_t *countp, int order, size_t size, int endian, size_t nails, const mpz_t op)`, and fills the buffer rop with data from the variable op. An astute reader can see several glaring flaws with this:
	1. With rop set to NULL, gmp will try to write to a NULL pointer, which is illegal, and will lead to an immediate SEGFAULT.

	2. The size argument in the function does not indicate the length of rop in bytes, like what the author seems to have thought, but tells the function to set *countp=(size of op in bytes)/(size).

	3. Since countp is NULL, it tells gmp to discard the size of the written data. This means that the caller is forced to send the entire buffer, instead of only the part that was written to. 

		Since a buffer is initialized with whatever memory is available, if the caller didn't take care to memset the memory to 0, then it could mean that when they send the buffer (if they actually had one), they are sending pieces of memory that still hold sensitive information (ie, bytes in the RAM that were discarded but still hold relevant information) to a (possibly) unknown party.

	4. With an endian set to 0, the bytes will be written in the native endianness of the host machine. This could lead to potential errors when exporting/importing across machines of different endiannesses, if the author does not take care to export and import using the same endianness.


Another set of flaws can be found in the lines 176 and 180 --- the author seems to think that one can read and write directly from a mpz_t type as a sequence of bytes (in that case, it is not clear what the purpose of the mpz_export call was). While this is valid in the sense that bytes will be written/sent, it is not valid in the sense that the bytes that are sent correspond to the actual value stored in the variable --- mpz_t are (currently) implemented as a pointer to a struct (technically, it is declared as an array of structs of length 1, but in C they are the same thing). This means that the type does not store the value directly, but instead holds a memory address. This means that the only bytes that are sent are the bytes that correspond to a memory address that is local to the originating process. However, a bigger problem is when a process receives the bytes --- while the recv call successfully writes the bytes to the received_public_key variable, when gmp tries to dereference the pointer to get the underlying structure, it will most likely crash if the memory address is invalid or non-allocated; but it could also deceivingly succeed (if the address is valid) and start working on some random piece of memory, either leading to a crash directly or some memory corruption which later leads to a crash (hmmmâ€¦. I wonder if there's an RCE vulnerability here).

Another flaw is on line 129 --- to make AES properly IND-CPA secure, the IV should be randomly generated each time (likely using the RAND_bytes, provided by the openssl library). However, while the IV is allocated, it is not initialized. While sometimes the memory allocated to IV has some random bytes to it, it likely does not have enough entropy to be fully secure. Additionally, most of the times IV is allocated, the allocated memory is full of 0s. This effectively makes the IV constant, and makes it easier for a would-be attacker to execute a known-plaintext attack.

The last flaw that was discovered (but almost certainly not the last flaw in general --- this program is positively riddled with them) is that handshakeProtocol (its declaration and subsequent definition starts on line 167) may have encryption (if it actually worked), but there's no authentication --- if a man-in-the-middle Mal was not only able to read traffic, but also modify it, or insert their own, then Mal can block the traffic from participant A, send its own public key to participant B, and B would be none the wiser. This means that Mal can pretend to be A simply because it knows the protocol.